// Generated by CoffeeScript 1.6.3
(function() {
  var PointTurns, PointsSet, evol, solver,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  importScripts('./underscore.js');

  importScripts('./solver.js');

  importScripts('./evolutionAlgorithm.js');

  importScripts('./gauss.js');

  importScripts('./gate.js');

  evol = {};

  evol.Individual = Individual;

  solver = {};

  solver.Skier = Skier;

  /*
  _ = require('./underscore.js')
  solver = require('./solver.js')
  evol = require('./evolutionAlgorithm.js')
  gauss = require('./gauss.js')
  */


  PointTurns = (function() {
    function PointTurns(del_y, count, val, gates, startPoint) {
      this.del_y = del_y;
      this.count = count;
      this.val = val;
      this.gates = gates;
      this.startPoint = startPoint != null ? startPoint : new Point(0, 0);
      this.idvs = [];
      this.getInitialPop();
    }

    PointTurns.prototype.getInitialPop = function() {
      var cur_y, gate, i, ind_i, points, rand_x, skier, startPoint, v0, x0, x_range, _i, _j, _len, _ref, _ref1, _results;
      _results = [];
      for (ind_i = _i = 1, _ref = this.count; 1 <= _ref ? _i <= _ref : _i >= _ref; ind_i = 1 <= _ref ? ++_i : --_i) {
        startPoint = null;
        points = [];
        cur_y = this.del_y;
        i = 0;
        _ref1 = this.gates;
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          gate = _ref1[_j];
          if (startPoint === null) {
            startPoint = this.startPoint;
          }
          if (startPoint.x > gate.x) {
            x_range = [gate.x, startPoint.x];
          } else {
            x_range = [startPoint.x, gate.x];
          }
          while (cur_y < gate.y) {
            rand_x = Math.random() * (x_range[1] - x_range[0]) + x_range[0];
            points.push(new Point(rand_x, cur_y));
            cur_y += this.del_y;
            i += 1;
          }
          cur_y = gate.y + this.del_y;
          points.push(gate.createCopy());
          startPoint = new Point(gate.x, gate.y);
          i += 1;
        }
        skier = new solver.Skier(0, null, 0, 0, null, x0 = [this.startPoint.x, this.startPoint.y], v0 = [0, this.val]);
        _results.push(this.idvs.push(new PointsSet(points, skier)));
      }
      return _results;
    };

    return PointTurns;

  })();

  PointsSet = (function(_super) {
    var computeRedundantEdgeChangePunish, punishFuntion, punishFuntion2,
      _this = this;

    __extends(PointsSet, _super);

    function PointsSet(points, skier) {
      this.skier = skier;
      this.computePunishment = __bind(this.computePunishment, this);
      this.computePunishFactor = __bind(this.computePunishFactor, this);
      this.setValue(points);
    }

    PointsSet.prototype.setValue = function(value) {
      var pos, vel;
      this.fitness = null;
      this.value = value;
      if (typeof skier !== "undefined" && skier !== null) {
        pos = this.skier.getPositions().reverse()[0];
        this.skier.positions = [pos[0], pos[1]];
        vel = this.skier.getVelocities().reverse()[0];
        this.skier.velocities = [vel[0], vel[1]];
      }
      return this.computeFitness();
    };

    punishFuntion = function(angle) {
      if (angle <= 90) {
        return 0.01;
      } else {
        return 1 - Math.pow((angle / 180.0) - 1.5, 6);
      }
    };

    punishFuntion2 = function(angle) {
      if (angle <= 90) {
        return 0.01;
      } else {
        return 2 * (angle / 180) - 1;
      }
    };

    PointsSet.prototype.computePunishFactor = function(positions) {
      var a, abx, aby, angba, angbc, angle, angles, b, c, cbx, cby, i, numberOfEdgeChange, punishFactors, rslt, _i, _len;
      i = 0;
      punishFactors = [];
      angles = [];
      punishFactors.push(1);
      while (i < positions.length - 2) {
        a = positions[i];
        b = positions[i + 1];
        c = positions[i + 2];
        abx = b.x - a.x;
        aby = b.y - a.y;
        cbx = b.x - c.x;
        cby = b.y - c.y;
        angba = Math.atan2(aby, abx);
        angbc = Math.atan2(cby, cbx);
        rslt = angba - angbc;
        angle = (rslt * 180) / 3.141592;
        angles.push(angle);
        i += 1;
      }
      i = 0;
      numberOfEdgeChange = 0;
      while (i < angles.length - 1) {
        if ((180 - angles[i + 1]) * (180 - angles[i]) < 0) {
          numberOfEdgeChange += 1;
        }
        i += 1;
      }
      for (_i = 0, _len = angles.length; _i < _len; _i++) {
        angle = angles[_i];
        if (angle > 180) {
          angle = 360 - angle;
        }
        punishFactors.push(punishFuntion(angle));
      }
      punishFactors.push(1);
      return {
        punishFactors: punishFactors,
        numberOfEdgeChange: numberOfEdgeChange
      };
    };

    PointsSet.prototype.computePunishment = function(positions) {
      var denominator, diff, i, item, numberOfEdgeChange, numerator, punish, sum, x1, x2, x3, y1, y2, y3, _ref, _ref1, _ref2;
      i = 0;
      diff = [];
      while (i < positions.length - 2) {
        _ref = positions[i + 2], x3 = _ref[0], y3 = _ref[1];
        _ref1 = positions[i + 1], x2 = _ref1[0], y2 = _ref1[1];
        _ref2 = positions[i], x1 = _ref2[0], y1 = _ref2[1];
        denominator = (y3 - y2) * (y2 - y1);
        numerator = x1 + x3 - 2 * x2;
        diff.push(numerator / denominator);
        i += 1;
      }
      i = 0;
      punish = [];
      numberOfEdgeChange = 0;
      while (i < diff.length - 1) {
        if (diff[i + 1] * diff[i] < 0) {
          numberOfEdgeChange += 1;
        }
        i += 1;
      }
      diff = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = diff.length; _i < _len; _i++) {
          item = diff[_i];
          _results.push(Math.abs(item) * item * item);
        }
        return _results;
      })();
      sum = diff.reduce(function(t, s) {
        return t + s;
      });
      return {
        sum: sum,
        numberOfEdgeChange: numberOfEdgeChange
      };
    };

    PointsSet.prototype.computeFitness = function() {
      var interval, t;
      if (this.fitness) {
        return this.fitness;
      }
      interval = 0.1;
      t = 0;
      this.min = 100000;
      return this.mySumPunishment();
    };

    computeRedundantEdgeChangePunish = function(numberOfEdgeChange, numberOfGates) {
      var numberOfRedundanChanges, numberOfRightChanges, redundantChangePunish;
      numberOfRightChanges = numberOfGates - 1;
      numberOfRedundanChanges = numberOfEdgeChange - numberOfRightChanges;
      if (numberOfRedundanChanges < 0) {
        throw "Number of redundant gates wrong!";
      }
      redundantChangePunish = 0;
      return numberOfRedundanChanges * redundantChangePunish;
    };

    PointsSet.prototype.mySumPunishment = function() {
      var factor, index, nextPos, result, _i, _len, _ref;
      _ref = this.value;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        nextPos = _ref[index];
        this.skier.moveStraightToPoint(1, [nextPos.x, nextPos.y], 0.001);
      }
      result = this.computePunishment(this.skier.positions);
      factor = result.sum;
      return this.fitness = factor * this.skier.result;
    };

    PointsSet.prototype.mySumPunishmentWithEgdeChangePunish = function() {
      var factor, index, nextPos, result, _i, _len, _ref;
      _ref = this.value;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        nextPos = _ref[index];
        this.skier.moveStraightToPoint(1, [nextPos.x, nextPos.y], 0.001);
      }
      result = this.computePunishment(this.skier.positions);
      factor = result.sum;
      return this.fitness = factor * (this.skier.result + computeRedundantEdgeChangePunish(result.numberOfEdgeChange, 5));
    };

    PointsSet.prototype.decreaseVelocityPunishment = function() {
      var index, nextPos, punishFactors, result, _i, _len, _ref;
      result = this.computePunishFactor([
        {
          x: 0,
          y: 0
        }
      ].concat(this.value));
      punishFactors = result.punishFactors;
      _ref = this.value;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        nextPos = _ref[index];
        this.skier.moveStraightToPoint(punishFactors[index], [nextPos.x, nextPos.y], 0.1);
      }
      return this.fitness = this.skier.result;
    };

    PointsSet.prototype.decreaseVelocityPunishmentWithEgdeChangePunis = function() {
      var index, nextPos, punishFactors, result, _i, _len, _ref;
      result = this.computePunishFactor([
        {
          x: 0,
          y: 0
        }
      ].concat(this.value));
      punishFactors = result.punishFactors;
      _ref = this.value;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        nextPos = _ref[index];
        this.skier.moveStraightToPoint(punishFactors[index], [nextPos.x, nextPos.y], 0.1);
      }
      return this.fitness = this.skier.result + computeRedundantEdgeChangePunish(result.numberOfEdgeChange, 7);
    };

    PointsSet.prototype.withEgdeChangePunis = function() {
      var index, nextPos, result, _i, _len, _ref;
      result = this.computePunishFactor([
        {
          x: 0,
          y: 0
        }
      ].concat(this.value));
      _ref = this.value;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        nextPos = _ref[index];
        this.skier.moveStraightToPoint(1, [nextPos.x, nextPos.y], 0.1);
      }
      return this.fitness = this.skier.result + computeRedundantEdgeChangePunish(result.numberOfEdgeChange, 7);
    };

    PointsSet.prototype.noPunish = function() {
      var index, nextPos, _i, _len, _ref;
      _ref = this.value;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        nextPos = _ref[index];
        this.skier.moveStraightToPoint(1, [nextPos.x, nextPos.y], 0.1);
      }
      return this.fitness = this.skier.result;
    };

    PointsSet.prototype.createCopy = function(changedPoints) {
      var firstPos, firstVel, skierPos, skierVel, v0, x0;
      skierPos = this.skier.getPositions();
      firstPos = skierPos[skierPos.length - 1];
      skierVel = this.skier.getVelocities();
      firstVel = skierVel[skierVel.length - 1];
      return new PointsSet(changedPoints, new solver.Skier(0, null, 0, 0, null, x0 = [firstPos[0], firstPos[1]], v0 = [firstVel[0], firstVel[1]]));
    };

    'mutate individual\ngaussAll - nrand value used for whole population in one iteration\ntau, tau_prim - parameters of evolutionary algorithm';

    PointsSet.prototype.mutate = function(gaussAll, tau, tau_prim) {
      var diff, gauss, i, newValue, old_value, point, _i, _len;
      newValue = (function() {
        var _i, _len, _ref, _results;
        _ref = this.value;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          i = _ref[_i];
          _results.push(i.createCopy());
        }
        return _results;
      }).call(this);
      for (_i = 0, _len = newValue.length; _i < _len; _i++) {
        point = newValue[_i];
        gauss = Math.nrand();
        if (!(point instanceof Gate)) {
          point.dev = point.dev * Math.exp(tau_prim * gaussAll + tau * gauss);
          gauss = Math.nrand();
          diff = point.dev * gauss;
          old_value = point.x;
          point.x += diff;
          while (!point.correct()) {
            gauss = Math.nrand();
            diff = point.dev * gauss;
            point.x = old_value + diff;
          }
        }
      }
      return this.createCopy(newValue);
    };

    PointsSet.prototype.cross = function(b) {
      var copy, crossed_points, i, _i, _ref;
      crossed_points = [];
      for (i = _i = 0, _ref = this.value.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        copy = this.value[i].createCopy();
        copy.x = (this.value[i].x + b.value[i].x) / 2;
        copy.dev = (this.value[i].dev + b.value[i].dev) / 2;
        crossed_points.push(copy);
      }
      return this.createCopy(crossed_points);
    };

    return PointsSet;

  }).call(this, evol.Individual);

  this.PointTurns = PointTurns;

  "pop = new PointTurns(1,20,1,[10,10])\n#console.log \"nowa populacja:\"\nfor i in pop.idvs.reverse()\n  console.log i.fitness\n  #for a in i.value\n  #console.log a\n\n#console.log ({fitness: i.fitness,points: ([a[0],a[1]] for a in i.value)} for i in pop.idvs.reverse())\n\n\nb = new evol.Optimization(pop,20,5).compute()\nconsole.log (i.fitness for i in pop.idvs.reverse())\nconsole.log b";

}).call(this);
