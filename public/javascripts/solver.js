// Generated by CoffeeScript 1.3.3
(function() {
  'this is a hack that enables the usage of this script in both: the browser via Web Workers or in Node.js';

  var B, Skier, Solver, alfa, cos, g, k1, lib, mag, pi, root, sign_omega, sin, sqrt, square,
    _this = this,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  lib = {};

  try {
    importScripts('./numeric.js');
    if (typeof numeric !== "undefined" && numeric !== null) {
      lib.numeric = numeric;
    }
  } catch (error) {
    lib.numeric = require("./numeric.js");
  }

  pi = Math.PI;

  sin = Math.sin;

  cos = Math.cos;

  sqrt = Math.sqrt;

  square = function(x) {
    return x * x;
  };

  mag = function(_arg) {
    var x, y;
    x = _arg[0], y = _arg[1];
    return Math.sqrt(square(x) + square(y));
  };

  g = 9.80665;

  sign_omega = -1;

  B = 4;

  k1 = 0.05;

  alfa = pi / 6;

  Skier = (function() {
    "C - drag coefficient, typical values (0.4 - 1)\nA - area of the skier exposed to the air";

    function Skier(mi, m, C, A) {
      this.mi = mi != null ? mi : 0.05;
      this.m = m != null ? m : 60;
      this.C = C != null ? C : 0.6;
      this.A = A != null ? A : 0.2;
      this.roh = 1.32;
      this.k2 = 0.5 * this.C * this.roh * this.A;
    }

    return Skier;

  })();

  Solver = (function() {
    var compute_sin_cos_beta, vectorfield,
      _this = this;

    function Solver() {
      this.solve = __bind(this.solve, this);

    }

    compute_sin_cos_beta = function(v0) {
      var cos_beta, eps, sin_beta, v0_length;
      v0_length = mag(v0);
      eps = 0.00001;
      if (v0_length <= eps) {
        cos_beta = 0.0;
        sin_beta = 1.0;
      } else {
        cos_beta = v0[0] / v0_length;
        sin_beta = v0[1] / v0_length;
      }
      return [sin_beta, cos_beta];
    };

    vectorfield = function(t, v, params) {
      var N, cosinus, f, f_R, f_r, kappa, sinus, skier, vl, _ref;
      _ref = [params.skier, params.kappa, params.sinus, params.cosinus], skier = _ref[0], kappa = _ref[1], sinus = _ref[2], cosinus = _ref[3];
      vl = mag([v[0], v[1]]);
      f_R = (square(vl)) * Math.abs(kappa);
      f_r = f_R + sign_omega * g * sin(alfa) * cosinus;
      if (f_r < 0) {
        f_r = sign_omega * g * sin(alfa) * cosinus;
        f_R = 0;
      }
      N = sqrt(square(g * cos(alfa)) + square(f_R));
      return f = [f_r * sinus * sign_omega - (skier.mi * N + k1 / skier.m * vl + square(skier.k2 / skier.m * vl)) * cosinus, g * sin(alfa) - f_r * cosinus * sign_omega - (skier.mi * N + k1 / skier.m * vl + skier.k2 / skier.m * square(vl)) * sinus];
    };

    Solver.prototype.solve = function(start, end, v0, _kappa, _skier) {
      var params, v0_length, _cosinus, _ref, _sinus;
      if (start == null) {
        start = 0;
      }
      if (end == null) {
        end = 1;
      }
      if (v0 == null) {
        v0 = [0, 19];
      }
      if (_kappa == null) {
        _kappa = 0.05;
      }
      if (_skier == null) {
        _skier = new Skier();
      }
      'Air drag is proportional to the square of velocity\nwhen the velocity is grater than some boundary value: B.\nk1 and k2 factors control whether we take square or linear proportion';

      v0_length = mag(v0);
      if (v0_length <= B) {
        skier.k2 = 0;
      } else {
        k1 = 0;
      }
      _ref = compute_sin_cos_beta(v0), _sinus = _ref[0], _cosinus = _ref[1];
      params = {
        kappa: _kappa,
        skier: _skier,
        sinus: _sinus,
        cosinus: _cosinus
      };
      return lib.numeric.dopri_params(start, end, v0, vectorfield, params);
    };

    return Solver;

  }).call(this);

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.OptimalGiant = {};

  root.OptimalGiant.solver = new Solver().solve;

}).call(this);
