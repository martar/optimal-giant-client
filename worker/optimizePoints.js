// Generated by CoffeeScript 1.3.3

/*
try

importScripts './underscore.js'
importScripts './solver.js'	
importScripts './evolutionAlgorithm.js'
evol = {}
evol.Individual = Individual
solver = {}
solver.Skier = Skier
*/


(function() {
  var PointTurns, PointsSet, evol, findCoords, solver, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require('./underscore.js');

  solver = require('./solver.js');

  evol = require('./evolutionAlgorithm.js');

  findCoords = function(value, length) {
    var coor, vProp;
    coor = [];
    vProp = Math.tan(value);
    coor.push(length / (Math.sqrt(1 + vProp * vProp)));
    coor.push(vProp * length / (Math.sqrt(1 + vProp * vProp)));
    return coor;
  };

  PointTurns = (function() {

    function PointTurns(del_x, count, val, endPoint, startPoint) {
      var angle, center, i, kappa, points, propEnd, randomAngles, skier, v0, x, x0, _i, _len;
      this.del_x = del_x;
      this.endPoint = endPoint;
      this.startPoint = startPoint != null ? startPoint : [0, 0];
      propEnd = (this.endPoint[1] - this.startPoint[1]) / (this.endPoint[0] - this.startPoint[0]);
      x = Math.atan(propEnd);
      randomAngles = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 1; 1 <= count ? _i <= count : _i >= count; i = 1 <= count ? ++_i : --_i) {
          _results.push(Math.random() * (Math.PI / 2 - Math.abs(x)) + Math.abs(x));
        }
        return _results;
      })();
      this.idvs = [];
      for (_i = 0, _len = randomAngles.length; _i < _len; _i++) {
        angle = randomAngles[_i];
        skier = new solver.Skier(0, null, 0, 0, null, x0 = this.startPoint, v0 = findCoords(angle, val));
        kappa = skier.computeKappa(this.endPoint);
        center = skier.getCircleCenter(this.endPoint);
        points = this.getPoints(1 / kappa, center);
        this.idvs.push(new PointsSet(points, skier));
      }
    }

    PointTurns.prototype.getPoints = function(R, center) {
      var cur_x, points, y;
      cur_x = this.startPoint[0] + this.del_x;
      points = [];
      while (cur_x < this.endPoint[0]) {
        y = Math.sqrt(Math.pow(R, 2) - Math.pow(center[0] - cur_x, 2)) + center[1];
        points.push([cur_x, y]);
        cur_x += this.del_x;
      }
      points.push(this.endPoint);
      return points;
    };

    return PointTurns;

  })();

  PointsSet = (function(_super) {

    __extends(PointsSet, _super);

    function PointsSet(points, skier) {
      this.skier = skier;
      this.setValue(points);
    }

    PointsSet.prototype.setValue = function(value) {
      var pos, vel;
      this.fitness = null;
      this.value = value;
      if (typeof skier !== "undefined" && skier !== null) {
        pos = this.skier.getPositions().reverse()[0];
        this.skier.positions = [pos[0], pos[1]];
        vel = this.skier.getVelocities().reverse()[0];
        this.skier.velocities = [vel[0], vel[1]];
      } else {
        this.skier.velocities;
      }
      return this.computeFitness();
    };

    PointsSet.prototype.computeFitness = function() {
      var interval, nextPos, t, _i, _len, _ref;
      if (this.fitness) {
        return this.fitness;
      }
      interval = 0.1;
      t = 0;
      this.min = 100000;
      _ref = this.value;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        nextPos = _ref[_i];
        this.skier.moveStraightToPoint(nextPos, 0.001);
      }
      return this.fitness = this.skier.result;
    };

    PointsSet.prototype.createCopy = function(changedPoints) {
      var firstPos, firstVel, skierPos, skierVel, v0, x0;
      skierPos = this.skier.getPositions();
      firstPos = skierPos[skierPos.length - 1];
      skierVel = this.skier.getVelocities();
      firstVel = skierVel[skierVel.length - 1];
      return new PointsSet(changedPoints, new solver.Skier(0, null, 0, 0, null, x0 = [firstPos[0], firstPos[1]], v0 = [firstVel[0], firstVel[1]]));
    };

    PointsSet.prototype.mutate = function(percentValue) {
      var diff, i, ind, indCount, newValue, _i;
      indCount = Math.floor(Math.random() * (this.value.length - 1));
      newValue = (function() {
        var _i, _len, _ref, _results;
        _ref = this.value;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          i = _ref[_i];
          _results.push([i[0], i[1]]);
        }
        return _results;
      }).call(this);
      for (i = _i = 1; 1 <= indCount ? _i <= indCount : _i >= indCount; i = 1 <= indCount ? ++_i : --_i) {
        ind = Math.floor(Math.random() * (this.value.length - 2));
        newValue[ind][1] = newValue[ind][1] + (Math.random() * percentValue * 2 - percentValue) * newValue[ind][1] / 100;
        'while ( (ind>0 && newValue[ind][1] < newValue[ind-1][1]) || newValue[ind][1] > newValue[ind+1][1] || (ind==0 && newValue[ind][1]<@skier.positions[0][1]))\nnewValue[ind][1] = newValue[ind][1] + (Math.random()*percentValue*2 - 	percentValue)*newValue[ind][1]/100';

        if (ind > 0 && (newValue[ind][1] > newValue[ind + 1][1] || newValue[ind][1] < newValue[ind - 1][1])) {
          diff = Math.random() * (newValue[ind + 1][1] - newValue[ind - 1][1]) - (newValue[ind][1] - newValue[ind - 1][1]);
          newValue[ind][1] = newValue[ind][1] + diff;
        }
      }
      return this.createCopy(newValue);
    };

    PointsSet.prototype.cross = function(b) {
      var i;
      return this.createCopy((function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.value.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push([this.value[i][0], (this.value[i][1] + b.value[i][1]) / 2]);
        }
        return _results;
      }).call(this));
    };

    return PointsSet;

  })(evol.Individual);

  this.PointTurns = PointTurns;

  "pop = new PointTurns(1,20,1,[10,10])\n#console.log \"nowa populacja:\"\nfor i in pop.idvs.reverse()\n	console.log i.fitness\n	#for a in i.value\n	#console.log a\n\n#console.log ({fitness: i.fitness,points: ([a[0],a[1]] for a in i.value)} for i in pop.idvs.reverse())\n\n\nb = new evol.Optimization(pop,20,5).compute()\nconsole.log (i.fitness for i in pop.idvs.reverse())\nconsole.log b";


}).call(this);
