// Generated by CoffeeScript 1.3.3
(function() {
  'this is a hack that enables the usage of this script in both: the browser via Web Workers or in Node.js';

  var B, Skier, Solver, alfa, cos, endPoint, findCoords, g, getCurveCoordinates, k1, kappa, lib, mag, pi, pos, root, sin, skier, skier2, sqrt, square, startPoint, steep, steepPositions, t0, v, vectorDistance, vstart, _i, _len,
    _this = this,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  lib = {};

  try {
    importScripts('./numeric.js');
    if (typeof numeric !== "undefined" && numeric !== null) {
      lib.numeric = numeric;
    }
  } catch (error) {
    lib.numeric = require("./numeric.js");
  }

  pi = Math.PI;

  sin = Math.sin;

  cos = Math.cos;

  sqrt = Math.sqrt;

  square = function(x) {
    return x * x;
  };

  mag = function(_arg) {
    var x, y;
    x = _arg[0], y = _arg[1];
    return Math.sqrt(square(x) + square(y));
  };

  g = 9.80665;

  B = 4;

  k1 = 0;

  alfa = pi / 6;

  Skier = (function() {
    "C - drag coefficient, typical values (0.4 - 1)\nA - area of the skier exposed to the air";

    function Skier(mi, m, C, A, solver, x0, v0) {
      this.mi = mi != null ? mi : 0.05;
      this.m = m != null ? m : 60;
      this.C = C != null ? C : 0.6;
      this.A = A != null ? A : 0.2;
      this.solver = solver != null ? solver : new Solver();
      this.x0 = x0 != null ? x0 : [0, 0];
      this.v0 = v0 != null ? v0 : [0, 19];
      this.roh = 1.32;
      this.k2 = 0.5 * this.C * this.roh * this.A;
      this.velocities = [v0];
      this.positions = [x0];
      this.result = 0;
    }

    Skier.prototype.whatIsMyResult = function(endPoint, result) {
      var index, lastIndex, reachedDestination, resultYSteep, vx, vy, xEnd, xx, xy, yEnd, _i, _len, _ref, _ref1;
      xEnd = endPoint[0], yEnd = endPoint[1];
      lastIndex = result.y.length - 1;
      reachedDestination = false;
      _ref = result.y;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        resultYSteep = _ref[index];
        xx = resultYSteep[0], xy = resultYSteep[1], vx = resultYSteep[2], vy = resultYSteep[3];
        if (xx > xEnd || xy > yEnd) {
          lastIndex = index;
          reachedDestination = true;
          break;
        }
      }
      _ref1 = result.y[lastIndex], xx = _ref1[0], xy = _ref1[1], vx = _ref1[2], vy = _ref1[3];
      this.positions.unshift([xx, xy]);
      this.velocities.unshift([vx, vy]);
      this.result = result.x[lastIndex];
      return reachedDestination;
    };

    Skier.prototype.move = function(t0, t1, kappa, endPoint, sign_omega) {
      var result;
      if (sign_omega == null) {
        sign_omega = 1;
      }
      result = this.solver.solve(t0, t1, this.positions[0], this.velocities[0], kappa, sign_omega, this);
      return this.whatIsMyResult(endPoint, result);
    };

    Skier.prototype.moveWithArbitraryV = function(v, steep, kappa, endPoint, sign_omega) {
      var result;
      if (sign_omega == null) {
        sign_omega = 1;
      }
      result = this.solver.solve(this.result, this.result + steep, this.positions[0], v, kappa, sign_omega, this);
      return this.whatIsMyResult(endPoint, result);
    };

    'Check if we are in the closest point to the endPoint\nIt is the condition to stop simulation';


    Skier.prototype.isNear = function(endPoint) {
      var min, rKw, x;
      min = 0.1;
      x = this.positions[0];
      rKw = Math.pow(x[0] - endPoint[0], 2) + Math.pow(x[1] - endPoint[1], 2);
      return rKw < min || x[0] > endPoint[0];
    };

    'Compute new kappa basing on set points and velocity vector';


    Skier.prototype.computeKappa = function(endPoint) {
      var kappa, vx, vy, x, x1, x2, y, y1, y2, _ref, _ref1;
      _ref = this.positions[0], x1 = _ref[0], y1 = _ref[1];
      x2 = endPoint[0], y2 = endPoint[1];
      _ref1 = this.velocities[0], vx = _ref1[0], vy = _ref1[1];
      x = (Math.pow(y2 - y1, 2) * vy - 2 * vx * x1 * (y2 - y1) + (Math.pow(x2, 2) - Math.pow(x1, 2)) * vy) / (2 * (-vx * (y2 - y1) + vy * (x2 - x1)));
      y = (-vx * (Math.pow(y2 - y1, 2) + (Math.pow(x2, 2) - Math.pow(x1, 2)))) / (2 * (-vx * (y2 - y1) + vy * (x2 - x1))) + y1;
      kappa = 1 / (Math.sqrt(Math.pow(x1 - x, 2) + Math.pow(y1 - y, 2)));
      return kappa;
    };

    Skier.prototype.getPosition = function() {
      return this.positions[0];
    };

    Skier.prototype.getPositions = function() {
      return this.positions;
    };

    Skier.prototype.getVelocities = function() {
      return this.velocities;
    };

    return Skier;

  })();

  Solver = (function() {
    var compute_sin_cos_beta, movementEquasion,
      _this = this;

    function Solver() {
      this.solve = __bind(this.solve, this);

    }

    compute_sin_cos_beta = function(v0) {
      var cos_beta, eps, sin_beta, v0_length;
      v0_length = mag(v0);
      eps = 0.00001;
      if (v0_length <= eps) {
        cos_beta = 0.0;
        sin_beta = 1.0;
      } else {
        cos_beta = v0[0] / v0_length;
        sin_beta = v0[1] / v0_length;
      }
      return [sin_beta, cos_beta];
    };

    movementEquasion = function(t, v, params) {
      var N, cosinus, f, f_R, f_r, kappa, sign_omega, sinus, skier, vl, vx, vy, _, _ref;
      _ = v[0], _ = v[1], vx = v[2], vy = v[3];
      _ref = [params.skier, params.kappa, params.sinus, params.cosinus, params.sign_omega], skier = _ref[0], kappa = _ref[1], sinus = _ref[2], cosinus = _ref[3], sign_omega = _ref[4];
      vl = mag([vx, vy]);
      f_R = (square(vl)) * Math.abs(kappa);
      f_r = f_R + sign_omega * g * sin(alfa) * cosinus;
      if (f_r < 0) {
        f_r = sign_omega * g * sin(alfa) * cosinus;
        f_R = 0;
      }
      N = sqrt(square(g * cos(alfa)) + square(f_R));
      return f = [vx, vy, f_r * sinus * sign_omega - (skier.mi * N + k1 / skier.m * vl + square(skier.k2 / skier.m * vl)) * cosinus, g * sin(alfa) - f_r * cosinus * sign_omega - (skier.mi * N + k1 / skier.m * vl + skier.k2 / skier.m * square(vl)) * sinus];
    };

    Solver.prototype.solve = function(start, end, x0, v0, kappa, sign_omega, skier) {
      var cosinus, params, sinus, v0_length, _ref;
      if (start == null) {
        start = 0;
      }
      if (end == null) {
        end = 1;
      }
      if (x0 == null) {
        x0 = [0, 0];
      }
      if (v0 == null) {
        v0 = [0, 19];
      }
      if (kappa == null) {
        kappa = 0.05;
      }
      if (sign_omega == null) {
        sign_omega = 1;
      }
      if (skier == null) {
        skier = new Skier();
      }
      'Air drag is proportional to the square of velocity\nwhen the velocity is grater than some boundary value: B.\nk1 and k2 factors control whether we take square or linear proportion';

      v0_length = mag(v0);
      if (v0_length <= B) {
        skier.k2 = 0;
      } else {
        k1 = 0;
      }
      _ref = compute_sin_cos_beta(v0), sinus = _ref[0], cosinus = _ref[1];
      params = {
        kappa: kappa,
        skier: skier,
        sinus: sinus,
        cosinus: cosinus,
        sign_omega: sign_omega
      };
      return lib.numeric.dopri(start, end, [x0[0], x0[1], v0[0], v0[1]], function(t, v) {
        return movementEquasion(t, v, params);
      });
    };

    return Solver;

  }).call(this);

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.OptimalGiant = {};

  root.OptimalGiant.Solver = Solver;

  this.Skier = Skier;

  'start = Date.now()                                                                    \nsteep = 0.01\nt0 = 0\nskier = new Skier(null, null, null, null, null, x0=[0,0], v0=[0,19])\n\nendPoint = [1,4]\nkappa = skier.computeKappa(endPoint)\nwhile !skier.isNear(endPoint)\n  t1 = t0+steep\n  skier.move(t0, t1, kappa)\n  t0 = t1\nconsole.log skier.getPosition()\nendPoint = [5,5]\nkappa = skier.computeKappa(endPoint)\nconsole.log kappa, t0\n\nwhile !skier.isNear(endPoint)\n  t1 = t0+steep\n  skier.move(t0, t1, kappa)\n  t0 = t1\nduration = Date.now() - start';


  vectorDistance = function(vector) {
    return Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2));
  };

  findCoords = function(vProp, length) {
    var coor;
    coor = [];
    coor.push(length / (Math.sqrt(1 + vProp * vProp)));
    coor.push(vProp * length / (Math.sqrt(1 + vProp * vProp)));
    return coor;
  };

  getCurveCoordinates = function(timeSteep, endPoint, skier, granulation) {
    var kappa, t0, t1, x;
    kappa = skier.computeKappa(endPoint);
    t0 = 0;
    while (!skier.isNear(endPoint)) {
      t1 = t0 + timeSteep;
      skier.move(t0, t1, kappa, pos);
      t0 = t1;
    }
    skier.result = t0;
    return ((function() {
      var _i, _len, _ref, _results, _step;
      _ref = skier.getPositions();
      _results = [];
      for (_i = 0, _len = _ref.length, _step = granulation; _i < _len; _i += _step) {
        x = _ref[_i];
        _results.push(x);
      }
      return _results;
    })()).reverse();
  };

  vstart = [1, 10];

  startPoint = [0, 0];

  skier = new Skier(this.mi = 0.00, this.m = 60, this.C = 0.0, this.A = 0.2, this.solver = new Solver, this.x0 = startPoint, this.v0 = vstart);

  steep = 0.001;

  t0 = 0;

  endPoint = [50, 50];

  steepPositions = getCurveCoordinates(steep, endPoint, skier, 100);

  skier2 = new Skier(this.mi = 0.00, this.m = 60, this.C = 0.0, this.A = 0.2, this.solver = new Solver, this.x0 = startPoint, this.v0 = vstart);

  kappa = 0.000001;

  t0 = 0;

  for (_i = 0, _len = steepPositions.length; _i < _len; _i++) {
    pos = steepPositions[_i];
    v = findCoords((pos[1] - skier2.getPositions()[0][1]) / (pos[0] - skier2.getPositions()[0][0]), vectorDistance(skier2.getVelocities()[0]));
    skier2.moveWithArbitraryV(v, steep, kappa, pos, 1);
    console.log(skier2.result);
    while (!skier2.isNear(pos)) {
      console.log(skier2.result);
      skier2.move(skier2.result, skier2.result + steep, kappa, pos, 1);
    }
    console.log("-----------------");
  }

}).call(this);
